# question 1
> 不要再这样写代码了。
## answer
### OK !

# question 2
> 查询维基百科的“达夫设备”词条，并且看看你能不能找到错误。将它与这里的版本对比，并且阅读文章来试着理解，为什么维基百科上的代码在你这里不能正常工作，但是对于汤姆·达夫可以。

## answer
Tom Duff的代码不是给 从memory复制到memory 设计的。他的代码的to指针可能指向的是类似uart控制器的tx寄存器那样的地址，只需要负责送就好了。

但是这个特点，在我们的实验代码中没有体现出来，我们的代码是从memory复制到memory的，所以Tom Duff的代码在这里不能正常工作，核心点就是它的to指针没有更新

# question 3
> 创建一些宏，来自动完成任意长度的这种设备。例如，你想创建32个case语句，并且不想手动把它们都写出来时，你会怎么办？你可以编写一次展开8个的宏吗？

## answer
### 1 批量展开
如果不想都写出来，可以写脚本统一生成，直接穷举哈哈。一般100以内也差不多了
也倒是也可以宏包宏的形式，可以少写一点, 宏无法动态展开，所以还是有一些工作量。这里case的数字是变的，所以需要一些特殊处理，可以使用8/16进制的表示方式来做打包处理

//完整代码：[macro_ex23.h](./ex3/macro_ex23.h)
```c
//先生成一个8进制的表示，0开头表示8进制，0x就是16进制. 用0x显得太长就用8进制
#define DUFFY_COPY_X(from, to, NUM1, NUM0) case 0##NUM1##NUM: *to++ = *from++;
//生成0-7每种情况，高位保留
#define DUFFY_COPY_0(from, to, MSB) DUFFY_COPY_X(from, to, MSB, 0)
#define DUFFY_COPY_1(from, to, MSB) DUFFY_COPY_X(from, to, MSB, 1)
#define DUFFY_COPY_2(from, to, MSB) DUFFY_COPY_X(from, to, MSB, 2)
#define DUFFY_COPY_3(from, to, MSB) DUFFY_COPY_X(from, to, MSB, 3)
#define DUFFY_COPY_4(from, to, MSB) DUFFY_COPY_X(from, to, MSB, 4)
#define DUFFY_COPY_5(from, to, MSB) DUFFY_COPY_X(from, to, MSB, 5)
#define DUFFY_COPY_6(from, to, MSB) DUFFY_COPY_X(from, to, MSB, 6)
#define DUFFY_COPY_7(from, to, MSB) DUFFY_COPY_X(from, to, MSB, 7)
//生成7-1，高位保留，用在数值小于8的场景
#define DUFFY_COPY_MSB_7_TO_1(from, to, MSB) \
    DUFFY_COPY_7(from, to, MSB) \
    DUFFY_COPY_6(from, to, MSB) \
    DUFFY_COPY_5(from, to, MSB) \
    DUFFY_COPY_4(from, to, MSB) \
    DUFFY_COPY_3(from, to, MSB) \
    DUFFY_COPY_2(from, to, MSB) \
    DUFFY_COPY_1(from, to, MSB)
//生成7-0，高位保留，用在数值大于8的场景
#define DUFFY_COPY_MSB_7_TO_0(from, to, MSB) \
        DUFFY_COPY_MSB_7_TO_1(from, to, MSB) \
        DUFFY_COPY_0(from, to, MSB)

//32个展开就是这个样子，case0在最前面，有单独的<{>, 所以只到1就好
#define DUFFY_COPY_2x_31_TO_1(from, to) \
        DUFFY_COPY_MSB_7_TO_0(from, to, 3) \
        DUFFY_COPY_MSB_7_TO_0(from, to, 2) \
        DUFFY_COPY_MSB_7_TO_0(from, to, 1) \
        DUFFY_COPY_MSB_7_TO_1(from, to, 0) \
```
### 展开8个的宏
见第一问中的C代码

# question 4
> 修改main函数，执行一些速度检测，来看看哪个实际上更快。
## answer
[code link](./ex4/ex23.c)

每一轮重复10000次，结果如下, 还是duffs_device最快
```
normal_copy: Elapsed time: 35.897 ms, 35896.728 us
duffs_device: Elapsed time: 16.299 ms, 16298.834 us
zeds_device: Elapsed time: 17.086 ms, 17086.279 us
```

# question 5
> 查询memcpy、memmove和memset，并且也比较一下它们的速度。

## answer
[code link](./ex5/ex23.c)
memset最快，memcpy memmove差不多

```sh
gmcao22@gmbits:~/code/ysyx_git/learn_c_hard_way/ex23/ex5$ ./ex23
memset: Elapsed time: 129.813 ms, 129813.460 us
memmove: Elapsed time: 152.157 ms, 152157.486 us
memcpy: Elapsed time: 154.809 ms, 154809.038 us
gmcao22@gmbits:~/code/ysyx_git/learn_c_hard_way/ex23/ex5$ ./ex23
memset: Elapsed time: 139.298 ms, 139298.005 us
memmove: Elapsed time: 168.377 ms, 168376.716 us
memcpy: Elapsed time: 170.982 ms, 170981.874 us
gmcao22@gmbits:~/code/ysyx_git/learn_c_hard_way/ex23/ex5$ ./ex23
memset: Elapsed time: 140.153 ms, 140152.751 us
memmove: Elapsed time: 164.708 ms, 164707.526 us
memcpy: Elapsed time: 165.436 ms, 165435.985 us
gmcao22@gmbits:~/code/ysyx_git/learn_c_hard_way/ex23/ex5$ ./ex23
memset: Elapsed time: 139.103 ms, 139102.773 us
memmove: Elapsed time: 161.327 ms, 161327.190 us
memcpy: Elapsed time: 160.736 ms, 160736.289 us
```

# question 6
> 不要再这样写代码了！
## answer
ok!  (●'◡'●)