# question 1
> 研究“值传递”和“引用传递”的差异，并且为二者编写示例。（译者注：C中没有引用传递，你可以搜索“指针传递”。）
## answer
```C
//pass value
void proc(int input_val) {
    input_val += 1;
    print("%d", input_val);
}

int testa = 0;
proc(testa);
proc(testa);


//pass reference
void proc_2(int *input_val) {
    (*input_val) += 1;
    print("%d", input_val);
}

int testb = 0;
proc_2(&testb);
proc_2(&testb);
```

# question 2
> 使用指针来访问原本不能访问的变量。
## answer

```C
struct inner_st{
    int val;
    int type;
};

struct outer_st {
    struct inner_st inner;
    int index;
};

//access field out of inner_p access range
int proc(struct inner_st * inner_p) {
    struct outer_st outer_p = (struct outer_st *)inner_p;

    printf("index is :%d", outer_p->index);
}
```
# question 3
> 使用Valgrind来观察错误的访问是什么样子。

## answer
skip

# question 4
> 编写一个递归调用并导致栈溢出的函数。如果不知道递归函数是什么的话，试着在scope_demo底部调用scope_demo本身，会形成一种循环。

## answer
[ex22_ex4_main.c](./ex22_ex4/main.c)

> valgrind output
> ```
> ==61989== Memcheck, a memory error detector
> ==61989== Copyright (C) 2002-2024, and GNU GPL'd, by Julian Seward et al.
> ==61989== Using Valgrind-3.25.1 and LibVEX; rerun with -h for copyright info
> ==61989== Command: ./main
> ==61989==
> ==61989== Stack overflow in thread #1: can't grow stack to 0x1ffe801000
> ==61989==
> ==61989== Process terminating with default action of signal 11 (SIGSEGV)
> ==61989==  Access not within mapped region at address 0x1FFE801FF8
> ==61989== Stack overflow in thread #1: can't grow stack to 0x1ffe801000
> ==61989==    at 0x400117D: stackoverflow (main.c:12)
> ==61989==  If you believe this happened as a result of a stack
> ==61989==  overflow in your program's main thread (unlikely but
> ==61989==  possible), you can try to increase the size of the
> ==61989==  main thread stack using the --main-stacksize= flag.
> ==61989==  The main thread stack size used in this run was 8388608.
> ==61989==
> ==61989== HEAP SUMMARY:
> ==61989==     in use at exit: 0 bytes in 0 blocks
> ==61989==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
> ==61989==
> ==61989== All heap blocks were freed -- no leaks are possible
> ==61989==
> ==61989== For lists of detected and suppressed errors, rerun with: -s
> ==61989== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
> Segmentation fault (core dumped)
> ```

# question 5
> 重新编写Makefile使之能够构建这些文件。
## answer
[Makefile](./Makefile)
```Makefile
CFLAGS=-Wall -g

ex22:
	cc -Wall -g -DNDEBUG -c -o ex22.o ex22.c
	cc -Wall -g -DNDEBUG    ex22_main.c ex22.o   -o ex22_main
```